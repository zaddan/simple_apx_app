#include <iostream>
using std::cout;
using std::endl;
#include <fstream>
using namespace std;
#include <cstring>
#include <vector>
enum STATUS {SUCCESS, FAILURE};
const int MAX_CHARS_PER_LINE = 2048;
const int MAX_TOKENS_PER_LINE = 40;
const char* const DELIMITER = " ";
#include "operatorFile_parser.h"
#include <unistd.h>
#define GetCurrentDir getcwd


/* Copyright (C) 
 * This program is free software; you can redistribute it and/or2015 - Behzad Boroujerdian
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 * 
 */





/** 
 * @brief this module is responsible for parsing the operator_sample.txt which is generated by the sc_parse_and_apx+_op_space_gen module in the python folder
 * Note: to understand the format of this file, take a look at src_parse_and_apx_op_space_gen module. Instead, you can also, run the run_tool_chain.py and look at the operator_sample.txt file generate by run_tool_chain
 * 
 * @param fileName: name of the file to parse
 * @param &VTypeInfo: and Output. This vector gets populated with the operator info from the input file
 * 
 * @return a status variable (whether the module failed or not)
 */
int operatorFileParser(string fileName, vector< vector<string> > &VTypeInfo)
{
  
  cout<<"here is the string: "<< fileName;
    // create a file-reading object
   ifstream fin;
  fin.open(fileName); // open a file
 
//
//  char cCurrentPath[FILENAME_MAX];
//
// if (!GetCurrentDir(cCurrentPath, sizeof(cCurrentPath)))
//     {
//     return errno;
//     }
//
//  cCurrentPath[sizeof(cCurrentPath) - 1] = '\0'; /* not really required */
//
//    printf ("The current working directory is %s", cCurrentPath);
//
//  
//  
  
if (!fin.good()){
      printf("the input file to operator_assigner is not found"); 
      return FAILURE; // exit if file not found
  } 
// read each line of the file
  while (!fin.eof())
  {
    // read an entire line into memory
    char buf[MAX_CHARS_PER_LINE];
    fin.getline(buf, MAX_CHARS_PER_LINE);
    // parse the line into blank-delimited tokens
    int n = 0; // a for-loop index
    
    // array to store memory addresses of the tokens in buf
    const char* token[MAX_TOKENS_PER_LINE] = {}; // initialize to 0
    
    // parse the line
    token[0] = strtok(buf, DELIMITER); // first token
    
    if (token[0]) // zero if line is blank
    {
      
    for (n = 1; n < MAX_TOKENS_PER_LINE; n++)
      {
        token[n] = strtok(0, DELIMITER); // subsequent tokens
        if (!token[n]) break; // no more tokens
      }
    }
    // process (print) the tokens
    vector <string> inputTypes;
    for (int i = 0; i < n; i++) {// n = #of tokens
        inputTypes.push_back(token[i]);  
    } 
    if (n > 0) { 
      VTypeInfo.push_back(inputTypes);
    } 
  }

//  for (int i =0; i<VTypeInfo.size(); i++){
//     for(int j= 0; j <VTypeInfo[i].size(); j++){
//        cout<<VTypeInfo[i][j]<<endl;
//    }
//  }
  return SUCCESS;

  
}

//int main() {
//    vector<vector<string> > VTypeInfo;
//    string fileName = "data.txt";
//   operatorFileParser(fileName, VTypeInfo);
//    for (int i =0; i < VTypeInfo.size(); i++){ 
//      vector<string> inputTypes = VTypeInfo[i]; 
//      for (int j =0; j <inputTypes.size(); j++) {
//        cout<< inputTypes[j]<<endl;
//      } 
//      cout <<endl; 
//    }
//}
